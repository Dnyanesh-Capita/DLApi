Index: lib/mongo_client.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/mongo_client.js	(date 1453774715000)
+++ lib/mongo_client.js	(revision )
@@ -12,14 +12,13 @@
 
 MongoClient.connect = function(url, options, callback) {
   callback = arguments[arguments.length - 1];
-  if(!options || callback===options) options = {};
   url = urlparse(url);
 
   var server = servers[url.host] || (servers[url.host] = { databases:{}, persist:MongoClient._persist });
   debug('connecting %s%s', url.host, url.pathname);
 
   var dbname = url.pathname.replace(/^\//, '');
-  new Db(dbname, server).open(callback);
+  return new Db(dbname, server).open(callback);
 };
 
 MongoClient._persist = persist;
Index: lib/collection.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/collection.js	(date 1453774715000)
+++ lib/collection.js	(revision )
@@ -33,6 +33,8 @@
     dropIndex: NotImplemented,
     dropIndexes: NotImplemented,
     ensureIndex: function (fieldOrSpec, options, callback) { throw Error('deprecated'); },
+
+    //TODO: find out if this supports Promises
     find: function () {
       var opts = find_options(arguments);
       debug('find %j callback=%s', opts, typeof opts.callback);
@@ -48,6 +50,8 @@
     },
     findAndModify: NotImplemented,
     findAndRemove: NotImplemented,
+
+    //TODO: find out if this supports Promises
     findOne: function () {
       var opts = find_options(arguments);
       debug('findOne %j callback=%s', opts, typeof opts.callback);
@@ -110,6 +114,7 @@
           ops: _.cloneDeep(docs, cloneObjectIDs)
         });
       });
+
       if(typeof callback!=='function') {
         return new Promise(function (resolve,reject) {
           callback = function (e, r) { e? reject(e) : resolve(r) };
Index: test/mock.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/mock.test.js	(date 1453774715000)
+++ test/mock.test.js	(revision )
@@ -10,11 +10,13 @@
   var collection;
 
   before(function (done) {
-    MongoClient.connect("mongodb://someserver/mock_database", function(err, db) {
+    MongoClient.connect("mongodb://someserver/mock_database")
+    .then(db=>{
       connected_db = db;
       collection = connected_db.collection("users");
       done();
-    });
+    })
+    .catch(done);
   });
 
 
Index: lib/db.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/db.js	(date 1453774715000)
+++ lib/db.js	(revision )
@@ -26,7 +26,7 @@
       clearInterval(open);
       open = false;
 
-      if(callback) callback();
+      if(callback) asyncish(callback);
       else return Promise.resolve();
     },
     collection: function(name, options, callback) {
@@ -34,6 +34,7 @@
       if(typeof callback !== 'function') callback = undefined;
       if(!options || callback===options) options = {};
 
+//TODO: dig into this more...
       if(options.strict && !callback)
         throw Error("A callback is required in strict mode. While getting collection " + name);
 
@@ -44,6 +45,9 @@
 
       if(callback) callback(null, collection);
       return collection;
+      //if(!callback)
+      //  return Promise.resolve(collection);
+      //callback(null, collection);
     },
     collections: NotImplemented,
     command: NotImplemented,
@@ -58,19 +62,19 @@
         if(collection.documents) {
           debug('createCollection("%s") - collection exists', name);
           if(options.strict)
-            return callback && callback(new Error("Collection " + name + " already exists. Currently in strict mode."));
-          return collection;
+            return callback(new Error("Collection " + name + " already exists. Currently in strict mode."));
         }
-
+        else {
-        debug('createCollection("%s") - materializing collection', name);
-        collection.persist(options.autoIndexId);
+          debug('createCollection("%s") - materializing collection', name);
+          collection.persist(options.autoIndexId);
+        }
 
         callback(null, collection);
       });
 
       if(typeof callback!=='function') {
-        return new Promise(function (resolve) {
-          callback = function (e, r) { resolve(r) };
+        return new Promise(function (resolve, reject) {
+          callback = function (e, r) { e? reject(e) : resolve(r) };
         })
       }
     },
@@ -96,10 +100,9 @@
       index = _.extend({}, options);
       if(index.v && index.v!==1) throw new Error("`v` not supported");
       if(index.dropDups) throw new Error("`dropDups` not supported. PR welcome!");
-      if(index.unique!==true && name !== '_id_') {
-        console.log(index);
+      if(index.unique!==true && name !== '_id_')
         throw new Error("only `unique` indexes are currently supported. PR welcome!");
-      }
+
       if(!index.name)
         index.name = Object.keys(keys).map(function(k){return k+'_'+keys[k]}).join('_');
       index.v = 1;
@@ -125,12 +128,13 @@
       if(typeof options !== 'object') options = {};
       if(!options.full) throw Error('only `options.full` is supported. PR welcome!');
 
-      if(typeof callback!=='function') {
-        return new Promise(function (resolve) {
-          callback = function (e, r) { resolve(r) };
-        })
-      }
-      callback(null, _.where(indexes, { ns:dbname+'.'+name }));
+      var info = _.where(indexes, { ns:dbname+'.'+name });
+      if(typeof callback!=='function')
+        return Promise.resolve(info);
+
+      asyncish(function () {
+        callback(null, info);
+      });
     },
     listCollections: function(filter, options) {
       debug('listCollections(%j)', filter);
